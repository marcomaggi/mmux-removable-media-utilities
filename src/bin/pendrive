#!/bin/bash
#
# Part of: Removable Media Utilities
# Contents: USB pendrive control
# Date: Fri May 24, 2013
#
# Abstract
#
#
#
# Copyright (C) 2013 Marco Maggi <marco.maggi-ipsu@poste.it>
#
# This  program  is free  software:  you  can redistribute  it
# and/or modify it  under the terms of the  GNU General Public
# License as published by the Free Software Foundation, either
# version  3 of  the License,  or (at  your option)  any later
# version.
#
# This  program is  distributed in  the hope  that it  will be
# useful, but  WITHOUT ANY WARRANTY; without  even the implied
# warranty  of  MERCHANTABILITY or  FITNESS  FOR A  PARTICULAR
# PURPOSE.   See  the  GNU  General Public  License  for  more
# details.
#
# You should  have received a  copy of the GNU  General Public
# License   along   with    this   program.    If   not,   see
# <http://www.gnu.org/licenses/>.
#

#page
#### global variables

declare -r script_PROGNAME=pendrive
declare -r script_VERSION=0.1d0

declare -r SCRIPT_ARGV0="$0"

declare -r SUDO='/usr/bin/sudo'
declare -r MOUNT='/bin/mount'
declare -r UMOUNT='/bin/umount'
declare -r GAWK='/usr/bin/gawk'
declare -r GREP='/usr/bin/grep'
declare -r ID='/usr/bin/id'

declare -r PENDRIVE_MOUNT_POINT=/mnt/stick

#page
#### main commands dispatching

declare -a ACTION_DISPATCH_KEYS=(mount umount sudo-mount sudo-umount version version-only help)
declare -A ACTION_DISPATCH_FUNS=(
    [mount]=script_action_mount
    [umount]=script_action_umount
    [sudo-mount]=script_action_sudo_mount
    [sudo-umount]=script_action_sudo_umount
    [help]=script_action_help
    [version]=script_action_version
    [version-only]=script_action_version_only)
declare -r ACTION_DISPATCH_KEYS ACTION_DISPATCH_FUNS

function script_action_mount () {
    local -r USR_ID=$("$ID" --user)
    local -r GRP_ID=$("$ID" --group)
    echo "$SUDO" "$SCRIPT_ARGV0" sudo-mount "$USR_ID" "$GRP_ID"
    if "$SUDO" "$SCRIPT_ARGV0" sudo-mount "$USR_ID" "$GRP_ID"
    then show_mount_point "$PENDRIVE_MOUNT_POINT"
    else print_error_message_and_exit 'error mounting USB pendrive'
    fi
}
function script_action_umount () {
    echo "$SUDO" "$SCRIPT_ARGV0" sudo-umount
    if "$SUDO" "$SCRIPT_ARGV0" sudo-umount
    then show_mount_point "$PENDRIVE_MOUNT_POINT"
    else print_error_message_and_exit 'error unmounting USB pendrive'
    fi
}
function script_action_sudo_mount () {
    local -r USR_ID=${1:?"$0: missing user ID"}
    local -r GRP_ID=${2:?"$0: missing group ID"}
    echo "$MOUNT" "$PENDRIVE_MOUNT_POINT" -o uid="$USR_ID",gid="$GRP_ID" >&2
    if "$MOUNT" "$PENDRIVE_MOUNT_POINT" -o uid="$USR_ID",gid="$GRP_ID"
    then true
    else
        # Not all  file systems  support UID and  GID options,  so retry
        # without those.
        echo "$MOUNT" "$PENDRIVE_MOUNT_POINT" >&2
        "$MOUNT" "$PENDRIVE_MOUNT_POINT"
    fi
}
function script_action_sudo_umount () {
    echo "$UMOUNT" "$PENDRIVE_MOUNT_POINT" >&2
         "$UMOUNT" "$PENDRIVE_MOUNT_POINT"
}
function script_action_help () {
    printf 'usage: %s COMMAND [options]
Manage USB pendrives.  Available COMMANDs:

   $ pendrive mount
   $ pendrive umount
   $ pendrive help
   $ pendrive version
   $ pendrive version-only
' "$script_PROGNAME"
    exit 2
}
function script_action_version () {
    printf '%s %s\n' "$script_PROGNAME" "$script_VERSION"
    exit 0
}
function script_action_version_only () {
    printf '%s\n' "$script_VERSION"
    exit 0
}

#page
#### helper functions

function show_mount_point () {
   "$MOUNT" -l | "$GREP" "$1" | "$GAWK" '
BEGIN {
   COLOR_NORM_GREEN="\033[32;40m"
   COLOR_BOLD_GREEN="\033[32;40;1m"
   COLOR_NORM_PURPLE="\033[35;40m"
   COLOR_BOLD_PURPLE="\033[35;40;1m"
   COLOR_NORM_YELLOW="\033[33;40m"
   COLOR_BOLD_YELLOW="\033[33;40;1m"
   COLOR_NORM_CYAN="\033[36;40m"
   COLOR_BOLD_CYAN="\033[36;40;1m"
   COLOR_RESET="\033[0m"
}
// {
   device=$1
   mount_point=$3
   fs_type=$5
   options=$6
   label1=$7
   label2=$8
   label3=$9
   printf "%s%-12s%s", \
     COLOR_BOLD_YELLOW, device, COLOR_RESET
   printf " on"
   printf " %s%-12s%s",
     COLOR_BOLD_CYAN, mount_point, COLOR_RESET
   printf " %s%s%s", COLOR_NORM_GREEN, fs_type, COLOR_RESET
   printf " %s", options
   printf " %s%s %s %s%s", \
     COLOR_BOLD_PURPLE, label1, label2, label3, COLOR_RESET
   printf "\n"
}'
}

#page
#### auxiliary functions

function print_error_message () {
    local MESSAGE=${1:?'missing error message argument'}
    printf '%s error: %s\n\n' "$script_PROGNAME" "$MESSAGE" >&2
}
function print_error_message_and_exit () {
    local MESSAGE=${1:?'missing error message argument'}
    print_error_message "$MESSAGE"
    exit 1
}
function printf_error_message () {
    local MESSAGE=$(printf "$@")
    print_error_message "$MESSAGE"
}
function printf_error_message_and_exit () {
    local MESSAGE=$(printf "$@")
    print_error_message_and_exit "$MESSAGE"
}

function print_warning_message () {
    local MESSAGE=${1:?'missing warning message argument'}
    printf '%s warning: %s\n' "$script_PROGNAME" "$MESSAGE" >&2
}
function printf_warning_message () {
    local MESSAGE=$(printf "$@")
    print_warning_message "$MESSAGE"
}

function print_verbose_message () {
    local MESSAGE=${1:?'missing verbose message argument'}
    printf '%s: %s\n' "$script_PROGNAME" "$MESSAGE" >&2
}
function printf_verbose_message () {
    local MESSAGE=$(printf "$@")
    print_verbose_message "$MESSAGE"
}

#page
#### script actions dispatching

function script_action () {
    local ACTION_KEY=${1:?"missing ACTION_KEY argument to '$FUNCNAME'"}
    local -a ACTION_KEYS=ACTION_${ACTION_KEY}_KEYS[@]
    local -a ACTION_FUNS=ACTION_${ACTION_KEY}_FUNS[@]
    shift 1
    if test 1 -le $#
    then
        local COMMAND=$1 KEY FUN
        shift 1
        for KEY in "${!ACTION_KEYS}"
        do
            if test "$KEY" = "$COMMAND"
            then
                FUN=ACTION_${ACTION_KEY}_FUNS[$KEY]
                ${!FUN} "$@"
                exit $?
            fi
        done
        printf_error_message_and_exit 'invalid subcommand: %s\n' "$COMMAND"
    else
        print_error_message_and_exit \
            'invalid number of arguments, use the "help" subcommand for details'
    fi
    exit 0
}

#page
#### done

script_action DISPATCH "$@"

### end of file
# Local Variables:
# mode: sh-mode
# End:
